<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YourGP Phone Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #f5f7fa;
            color: #333;
            padding: 20px;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .header h1 {
            font-size: 24px;
            color: #2c3e50;
        }
        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .file-upload {
            position: relative;
        }
        .file-upload input[type="file"] {
            display: none;
        }
        .file-upload label, .btn {
            background: #3498db;
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            border: none;
            transition: background 0.2s;
        }
        .file-upload label:hover, .btn:hover {
            background: #2980b9;
        }
        .btn.active {
            background: #27ae60;
        }
        .view-toggle {
            display: flex;
            gap: 5px;
        }
        .view-toggle .btn {
            padding: 8px 16px;
            background: #bdc3c7;
        }
        .view-toggle .btn.active {
            background: #3498db;
        }
        .week-info {
            font-size: 14px;
            color: #7f8c8d;
            background: white;
            padding: 8px 15px;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }
        .metric-card {
            background: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        .metric-card .value {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
        }
        .metric-card .label {
            font-size: 11px;
            color: #7f8c8d;
            margin-top: 5px;
            text-transform: uppercase;
        }
        .metric-card.danger .value {
            color: #e74c3c;
        }
        .metric-card.success .value {
            color: #27ae60;
        }
        .metric-card.info .value {
            color: #3498db;
        }
        .metric-card.warning .value {
            color: #f39c12;
        }
        .metric-card.purple .value {
            color: #9b59b6;
        }
        .section {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        .section h2 {
            font-size: 16px;
            color: #2c3e50;
            margin-bottom: 15px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 8px;
        }
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }
        .section-header h2 {
            margin-bottom: 0;
            border-bottom: none;
            padding-bottom: 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        th, td {
            padding: 10px 8px;
            text-align: center;
            border-bottom: 1px solid #ecf0f1;
        }
        th {
            background: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
        }
        tr:hover {
            background: #f8f9fa;
        }
        .heatmap-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        @media (max-width: 900px) {
            .heatmap-container {
                grid-template-columns: 1fr;
            }
        }
        .heatmap-wrapper {
            overflow-x: auto;
        }
        .heatmap {
            display: grid;
            grid-template-columns: 80px repeat(6, 1fr);
            gap: 2px;
            font-size: 11px;
        }
        .heatmap-cell {
            padding: 6px 4px;
            text-align: center;
            border-radius: 3px;
            min-width: 50px;
        }
        .heatmap-header {
            background: #f8f9fa;
            font-weight: 600;
        }
        .heatmap-time {
            background: #f8f9fa;
            font-weight: 500;
            text-align: right;
            padding-right: 8px;
        }
        .heat-0 { background: #f8f9fa; }
        .heat-1 { background: #d4edda; }
        .heat-2 { background: #a8d5ba; }
        .heat-3 { background: #7cc49a; }
        .heat-4 { background: #5cb377; }
        .heat-5 { background: #3d9d5d; color: white; }
        .heat-6 { background: #2d8a4e; color: white; }
        .heat-7 { background: #1e7640; color: white; }
        /* Wait time heatmap colors (green=good/fast, red=bad/slow) */
        .wait-heat-0 { background: #f8f9fa; }
        .wait-heat-1 { background: #d4edda; }
        .wait-heat-2 { background: #fff3cd; }
        .wait-heat-3 { background: #ffeaa7; }
        .wait-heat-4 { background: #fdcb6e; }
        .wait-heat-5 { background: #e17055; color: white; }
        .wait-heat-6 { background: #d63031; color: white; }
        .wait-heat-7 { background: #c0392b; color: white; }
        .no-data {
            text-align: center;
            padding: 60px 20px;
            color: #7f8c8d;
        }
        .no-data h3 {
            font-size: 18px;
            margin-bottom: 10px;
        }
        #loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
        }
        .direction-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        .direction-tabs .btn {
            padding: 6px 14px;
            font-size: 12px;
            background: #ecf0f1;
            color: #333;
        }
        .direction-tabs .btn.active {
            background: #3498db;
            color: white;
        }
        .service-level-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }
        .service-level-selector select {
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
            font-size: 12px;
        }
        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
        }
        .abandonment-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        .abandonment-bucket {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            text-align: center;
        }
        .abandonment-bucket .count {
            font-size: 20px;
            font-weight: 700;
            color: #e74c3c;
        }
        .abandonment-bucket .range {
            font-size: 11px;
            color: #7f8c8d;
            margin-top: 4px;
        }
        .abandonment-bucket .pct {
            font-size: 10px;
            color: #95a5a6;
            margin-top: 2px;
        }
        .two-col-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        @media (max-width: 900px) {
            .two-col-grid {
                grid-template-columns: 1fr;
            }
        }
        .followup-cards {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }
        .followup-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        .followup-card.lost {
            border-left: 4px solid #e74c3c;
        }
        .followup-card.persistent {
            border-left: 4px solid #f39c12;
        }
        .followup-card .big-number {
            font-size: 32px;
            font-weight: 700;
            color: #2c3e50;
        }
        .followup-card.lost .big-number {
            color: #e74c3c;
        }
        .followup-card.persistent .big-number {
            color: #f39c12;
        }
        .followup-card .card-label {
            font-size: 12px;
            color: #7f8c8d;
            margin-top: 5px;
        }
        .followup-card .card-detail {
            font-size: 11px;
            color: #95a5a6;
            margin-top: 8px;
        }
        .expand-btn {
            background: none;
            border: 1px solid #ddd;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: #666;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .expand-btn:hover {
            background: #f8f9fa;
        }
        .expand-btn .arrow {
            transition: transform 0.2s;
        }
        .expand-btn.expanded .arrow {
            transform: rotate(180deg);
        }
        .detail-section {
            display: none;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }
        .detail-section.visible {
            display: block;
        }
        .detail-section h4 {
            font-size: 12px;
            color: #2c3e50;
            margin-bottom: 10px;
            text-transform: uppercase;
        }
        .detail-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 8px;
            margin-bottom: 15px;
        }
        .detail-item {
            background: white;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }
        .detail-item .count {
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
        }
        .detail-item .label {
            font-size: 10px;
            color: #7f8c8d;
        }
        .peak-hours {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .peak-hour-tag {
            background: #fff3e0;
            color: #e65100;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>YourGP Phone Dashboard</h1>
        <div class="controls">
            <div class="file-upload">
                <input type="file" id="fileInput" accept=".csv">
                <label for="fileInput">üìÅ Upload CSV</label>
            </div>
            <div class="week-info" id="weekInfo">No data loaded</div>
            <div class="view-toggle">
                <button class="btn active" id="viewAll" onclick="setView('all')">All Calls</button>
                <button class="btn" id="viewVasectomy" onclick="setView('vasectomy')">Vasectomy</button>
            </div>
            <div class="service-level-selector">
                <label for="globalLocationFilter">Location:</label>
                <select id="globalLocationFilter" onchange="setGlobalLocation()">
                    <option value="all">All Locations</option>
                    <option value="crace">Crace</option>
                    <option value="denman">Denman</option>
                    <option value="lyneham">Lyneham</option>
                </select>
            </div>
        </div>
    </div>

    <div id="loading">Loading and processing data...</div>

    <div id="noData" class="no-data">
        <h3>No Data Loaded</h3>
        <p>Upload a CSV file (e.g., ExportCallRecords_20260112_20260118.csv) to get started.</p>
    </div>

    <div id="dashboard" style="display: none;">
        <!-- Summary Metrics -->
        <p style="font-size: 12px; color: #7f8c8d; margin-bottom: 10px;">Note: Calls answered in under 20 seconds are excluded from statistics. Hover over cards for explanations.</p>
        <div class="metrics-grid" id="metricsGrid">
            <div class="metric-card" title="Total incoming calls during opening hours (excludes calls answered under 20 seconds)">
                <div class="value" id="totalCalls">-</div>
                <div class="label">Total Calls</div>
            </div>
            <div class="metric-card success" title="Calls that were picked up by staff (answered in 20+ seconds)">
                <div class="value" id="answeredCalls">-</div>
                <div class="label">Answered</div>
            </div>
            <div class="metric-card danger" title="Calls that rang but were not answered before the caller hung up">
                <div class="value" id="missedCalls">-</div>
                <div class="label">Missed</div>
            </div>
            <div class="metric-card danger" title="Percentage of incoming calls that were missed">
                <div class="value" id="missedPercent">-</div>
                <div class="label">Missed %</div>
            </div>
            <div class="metric-card info" title="Percentage of calls answered within the target time (configurable below)">
                <div class="value" id="serviceLevel">-</div>
                <div class="label">Service Level</div>
            </div>
            <div class="metric-card success" title="First Call Resolution - estimated percentage of callers who didn't need to call back within 24 hours">
                <div class="value" id="fcrRate">-</div>
                <div class="label">FCR (Est.)</div>
            </div>
            <div class="metric-card warning" title="Percentage of unique callers who called more than once within 24 hours">
                <div class="value" id="callbackRate">-</div>
                <div class="label">Callback Rate</div>
            </div>
            <div class="metric-card" title="Average time callers waited before being answered">
                <div class="value" id="avgWait">-</div>
                <div class="label">Avg Wait</div>
            </div>
            <div class="metric-card" title="Longest wait time for any answered call in this period">
                <div class="value" id="maxWait">-</div>
                <div class="label">Max Wait</div>
            </div>
            <div class="metric-card" title="Average duration of answered calls (excluding ring time)">
                <div class="value" id="avgCallLength">-</div>
                <div class="label">Avg Call Length</div>
            </div>
            <div class="metric-card purple" title="Incoming calls received outside business hours (not included in other metrics)">
                <div class="value" id="outOfHoursCalls">-</div>
                <div class="label">Out of Hours</div>
            </div>
        </div>

        <!-- Service Level Target Selector -->
        <div style="margin-bottom: 20px; display: flex; align-items: center; gap: 15px;">
            <div class="service-level-selector">
                <label for="slTarget">Service Level Target:</label>
                <select id="slTarget" onchange="updateServiceLevelTarget()">
                    <option value="30">30 seconds</option>
                    <option value="60">60 seconds</option>
                    <option value="90" selected>90 seconds</option>
                    <option value="120">120 seconds</option>
                </select>
            </div>
        </div>

        <!-- Hourly Trend and Abandonment Analysis -->
        <div class="two-col-grid">
            <!-- Hourly Trend Chart -->
            <div class="section">
                <h2>Hourly Call Volume</h2>
                <div class="chart-container">
                    <canvas id="hourlyChart"></canvas>
                </div>
            </div>

            <!-- Abandonment Analysis -->
            <div class="section">
                <h2>Abandonment Analysis</h2>
                <p style="font-size: 12px; color: #7f8c8d; margin-bottom: 10px;">Wait time before caller hung up (missed calls only)</p>
                <div style="display: flex; gap: 20px; align-items: center; margin-bottom: 15px;">
                    <div>
                        <span style="font-size: 11px; color: #7f8c8d;">Total Abandoned:</span>
                        <span id="totalAbandoned" style="font-size: 18px; font-weight: 700; color: #e74c3c; margin-left: 5px;">-</span>
                    </div>
                    <div>
                        <span style="font-size: 11px; color: #7f8c8d;">Avg Wait Before Abandon:</span>
                        <span id="avgAbandonWait" style="font-size: 18px; font-weight: 700; color: #e74c3c; margin-left: 5px;">-</span>
                    </div>
                </div>
                <div class="abandonment-grid" id="abandonmentGrid">
                    <!-- Filled by JS -->
                </div>
            </div>
        </div>

        <!-- Missed Call Follow-up Analysis -->
        <div class="section">
            <div class="section-header">
                <h2 id="followupHeader">Missed Call Follow-up (24h Window)</h2>
                <div class="service-level-selector">
                    <label for="callbackWindow">Window:</label>
                    <select id="callbackWindow" onchange="updateCallbackWindow()">
                        <option value="24" selected>24 hours</option>
                        <option value="48">2 days</option>
                        <option value="72">3 days</option>
                    </select>
                </div>
            </div>
            <p style="font-size: 12px; color: #7f8c8d; margin-bottom: 15px;">What happens to callers whose first call was missed?</p>

            <div class="followup-cards">
                <div class="followup-card lost">
                    <div class="big-number" id="lostOpportunities">-</div>
                    <div class="card-label">Lost Opportunities</div>
                    <div class="card-detail">(never called back)</div>
                    <div class="card-detail" id="lostPeakHour" style="margin-top: 5px; font-weight: 500;">-</div>
                </div>
                <div class="followup-card persistent">
                    <div class="big-number" id="persistentCallers">-</div>
                    <div class="card-label">Persistent Callers</div>
                    <div class="card-detail">(called back)</div>
                    <div class="card-detail" id="avgAttempts" style="margin-top: 5px; font-weight: 500;">-</div>
                </div>
            </div>

            <button class="expand-btn" id="followupExpandBtn" onclick="toggleFollowupDetails()">
                <span class="arrow">&#9660;</span> Show Details
            </button>

            <div class="detail-section" id="followupDetails">
                <h4>Callback Attempts Distribution</h4>
                <div class="detail-grid" id="attemptsGrid"></div>

                <h4>Lost Opportunity Peak Hours</h4>
                <div class="peak-hours" id="lostPeakHours"></div>

                <div style="margin-top: 15px;">
                    <span style="font-size: 11px; color: #7f8c8d;">Avg Wait Before Hanging Up:</span>
                    <span id="avgWaitBeforeHangup" style="font-size: 16px; font-weight: 600; color: #e74c3c; margin-left: 8px;">-</span>
                </div>
            </div>
        </div>

        <!-- Direction Tabs for Daily Table -->
        <div class="section">
            <h2>Daily Breakdown</h2>
            <div class="direction-tabs">
                <button class="btn active" id="tabInOut" onclick="setDailyDirection('all')">All</button>
                <button class="btn" id="tabIn" onclick="setDailyDirection('in')">Calls In</button>
                <button class="btn" id="tabOut" onclick="setDailyDirection('out')">Calls Out</button>
            </div>
            <table id="dailyTable">
                <thead>
                    <tr>
                        <th>Metric</th>
                        <th>Mon</th>
                        <th>Tue</th>
                        <th>Wed</th>
                        <th>Thu</th>
                        <th>Fri</th>
                        <th>Sat</th>
                        <th>Sun</th>
                        <th>Week</th>
                    </tr>
                </thead>
                <tbody id="dailyTableBody"></tbody>
            </table>
        </div>

        <!-- Heatmaps -->
        <div class="section">
            <h2>Call Volume Heatmaps (7:30 AM - 5:30 PM)</h2>
            <div class="heatmap-container">
                <div>
                    <h3 style="font-size: 14px; margin-bottom: 10px; color: #27ae60;">üìû Calls In</h3>
                    <div class="heatmap-wrapper">
                        <div class="heatmap" id="heatmapIn"></div>
                    </div>
                </div>
                <div>
                    <h3 style="font-size: 14px; margin-bottom: 10px; color: #3498db;">üì§ Calls Out</h3>
                    <div class="heatmap-wrapper">
                        <div class="heatmap" id="heatmapOut"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Wait Time Heatmaps -->
        <div class="section">
            <h2>Wait Time Heatmaps (7:30 AM - 5:30 PM)</h2>
            <p style="font-size: 12px; color: #7f8c8d; margin-bottom: 15px;">Incoming calls only. Green = fast pickup, Red = long wait.</p>
            <div class="heatmap-container">
                <div>
                    <h3 style="font-size: 14px; margin-bottom: 10px; color: #e74c3c;">‚è±Ô∏è Max Wait Time</h3>
                    <div class="heatmap-wrapper">
                        <div class="heatmap" id="heatmapMaxWait"></div>
                    </div>
                </div>
                <div>
                    <h3 style="font-size: 14px; margin-bottom: 10px; color: #f39c12;">‚è±Ô∏è Avg Wait Time</h3>
                    <div class="heatmap-wrapper">
                        <div class="heatmap" id="heatmapAvgWait"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Staff Performance -->
        <div class="section">
            <div class="section-header">
                <h2>Staff Performance</h2>
                <div class="service-level-selector">
                    <label for="locationFilter">Location:</label>
                    <select id="locationFilter" onchange="updateStaffTableFilter()">
                        <option value="all">All Locations</option>
                        <option value="crace">Crace</option>
                        <option value="denman">Denman</option>
                        <option value="lyneham">Lyneham</option>
                    </select>
                </div>
            </div>
            <table id="staffTable">
                <thead>
                    <tr>
                        <th style="text-align: left;">Staff Member</th>
                        <th>Calls In</th>
                        <th>Calls Out</th>
                        <th>Total Calls</th>
                        <th>Avg Pickup Time</th>
                        <th>Avg Call In</th>
                        <th>Avg Call Out</th>
                    </tr>
                </thead>
                <tbody id="staffTableBody"></tbody>
            </table>
        </div>
    </div>

    <script>
        // Global state
        let rawData = [];
        let currentView = 'all'; // 'all' or 'vasectomy'
        let currentDailyDirection = 'all'; // 'all', 'in', or 'out'
        let serviceLevelTarget = 90; // Default 90 seconds
        let currentLocationFilter = 'all'; // 'all', 'crace', 'denman', or 'lyneham' (for staff table only)
        let currentGlobalLocation = 'all'; // 'all', 'crace', 'denman', or 'lyneham' (for entire dashboard)
        let hourlyChart = null;
        let callbackWindowHours = 24; // Default 24 hours for callback/FCR calculations

        // Minimum pickup time threshold (in seconds) - calls answered faster than this are excluded
        const MIN_PICKUP_TIME = 20;

        // Opening hours filter - excludes calls outside business hours
        function isWithinOpeningHours(dateValue) {
            const date = getDateObj(dateValue);
            if (!date) return false;

            const dayOfWeek = date.getDay(); // 0=Sun, 1=Mon, ..., 6=Sat
            const hours = date.getHours();
            const minutes = date.getMinutes();
            const timeInMinutes = hours * 60 + minutes;

            // Sunday = closed
            if (dayOfWeek === 0) return false;

            // Saturday: 9:00am (540) - 12:30pm (750)
            if (dayOfWeek === 6) {
                return timeInMinutes >= 540 && timeInMinutes <= 750;
            }

            // Mon-Fri: 7:30am (450) - 5:30pm (1050)
            return timeInMinutes >= 450 && timeInMinutes <= 1050;
        }

        // File upload handler
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            document.getElementById('loading').style.display = 'block';
            document.getElementById('noData').style.display = 'none';
            document.getElementById('dashboard').style.display = 'none';

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' }); // No cellDates - parse DD/MM/YYYY manually in getDateObj()

                    // CSV files have a single sheet - use the first one
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    rawData = XLSX.utils.sheet_to_json(worksheet);

                    console.log('Loaded', rawData.length, 'records from CSV');
                    console.log('Sample record:', rawData[0]);

                    processAndDisplay();
                } catch (err) {
                    console.error('Error reading file:', err);
                    alert('Error reading CSV file: ' + err.message);
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('noData').style.display = 'block';
                }
            };
            reader.readAsArrayBuffer(file);
        });

        // View toggle
        function setView(view) {
            currentView = view;
            document.getElementById('viewAll').classList.toggle('active', view === 'all');
            document.getElementById('viewVasectomy').classList.toggle('active', view === 'vasectomy');
            if (rawData.length > 0) {
                processAndDisplay();
            }
        }

        // Daily direction toggle
        function setDailyDirection(direction) {
            currentDailyDirection = direction;
            document.getElementById('tabInOut').classList.toggle('active', direction === 'all');
            document.getElementById('tabIn').classList.toggle('active', direction === 'in');
            document.getElementById('tabOut').classList.toggle('active', direction === 'out');
            if (rawData.length > 0) {
                updateDailyTable();
            }
        }

        // Service level target update
        function updateServiceLevelTarget() {
            serviceLevelTarget = parseInt(document.getElementById('slTarget').value);
            if (rawData.length > 0) {
                const filteredData = getGlobalFilteredData();
                const incomingCalls = filteredData.filter(row => row.Direction === 'In');
                updateSummaryMetrics(incomingCalls);
            }
        }

        function updateCallbackWindow() {
            callbackWindowHours = parseInt(document.getElementById('callbackWindow').value);
            // Update header text
            const windowText = callbackWindowHours === 24 ? '24h' : (callbackWindowHours / 24) + ' day';
            document.getElementById('followupHeader').textContent = `Missed Call Follow-up (${windowText} Window)`;
            // Update tooltips
            const windowDesc = callbackWindowHours === 24 ? '24 hours' : (callbackWindowHours / 24) + ' days';
            document.getElementById('fcrRate').parentElement.title = `First Call Resolution - estimated percentage of callers who didn't need to call back within ${windowDesc}`;
            document.getElementById('callbackRate').parentElement.title = `Percentage of unique callers who called more than once within ${windowDesc}`;
            // Recalculate if data loaded
            if (rawData.length > 0) {
                const filteredData = getGlobalFilteredData();
                const incomingCalls = filteredData.filter(row => row.Direction === 'In');
                updateSummaryMetrics(incomingCalls);
                updateMissedCallFollowup(incomingCalls);
            }
        }

        // Global location filter - applies to entire dashboard
        function setGlobalLocation() {
            currentGlobalLocation = document.getElementById('globalLocationFilter').value;
            if (rawData.length > 0) {
                processAndDisplay();
            }
        }

        // Location filter for staff table (additional filter on top of global)
        function updateStaffTableFilter() {
            currentLocationFilter = document.getElementById('locationFilter').value;
            if (rawData.length > 0) {
                let filteredData = getGlobalFilteredData();
                updateStaffTable(filteredData);
            }
        }

        // Filter data by location
        function filterByLocation(data, location) {
            if (location === 'all') return data;
            const locationLower = location.toLowerCase();
            return data.filter(row => {
                const office = (row.OfficeName || '').toLowerCase();
                return office.includes(locationLower);
            });
        }

        // Get data filtered by global location and view (vasectomy)
        function getGlobalFilteredData() {
            let filteredData = rawData;

            // Apply opening hours filter first (Mon-Fri 7:45am-5:30pm, Sat 9am-12:30pm, Sun closed)
            filteredData = filteredData.filter(row => isWithinOpeningHours(row.CallDateTime));

            // Apply global location filter
            filteredData = filterByLocation(filteredData, currentGlobalLocation);

            // Then apply vasectomy filter if needed
            if (currentView === 'vasectomy') {
                filteredData = filteredData.filter(row => row.CallAlertName === 'Canberra Vasectomy');
            }

            return filteredData;
        }

        // Format seconds to mm:ss or hh:mm:ss
        function formatTime(seconds) {
            if (seconds === null || seconds === undefined || isNaN(seconds)) return '-';
            seconds = Math.round(seconds);
            if (seconds < 60) return `${seconds}s`;
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            if (mins < 60) return `${mins}m ${secs}s`;
            const hrs = Math.floor(mins / 60);
            return `${hrs}h ${mins % 60}m`;
        }

        // Format time for compact display
        function formatTimeShort(seconds) {
            if (seconds === null || seconds === undefined || isNaN(seconds)) return '-';
            seconds = Math.round(seconds);
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Get date object from various formats
        function getDateObj(dateValue) {
            if (dateValue instanceof Date) return dateValue;
            if (typeof dateValue === 'number') {
                // Excel serial number - convert to local date (not UTC)
                // Excel epoch is Dec 30, 1899 (day 0)
                const excelEpoch = new Date(1899, 11, 30); // Dec 30, 1899
                const days = Math.floor(dateValue);
                const timeFraction = dateValue - days;
                const date = new Date(excelEpoch.getTime() + days * 86400 * 1000);
                // Add time portion
                const totalSeconds = Math.round(timeFraction * 86400);
                date.setHours(Math.floor(totalSeconds / 3600));
                date.setMinutes(Math.floor((totalSeconds % 3600) / 60));
                date.setSeconds(totalSeconds % 60);
                return date;
            }
            if (typeof dateValue === 'string') {
                // Handle DD/MM/YYYY or DD/MM/YYYY HH:MM:SS format (Australian date format)
                const ddmmyyyyMatch = dateValue.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?)?/);
                if (ddmmyyyyMatch) {
                    const day = parseInt(ddmmyyyyMatch[1]);
                    const month = parseInt(ddmmyyyyMatch[2]) - 1; // JS months are 0-indexed
                    const year = parseInt(ddmmyyyyMatch[3]);
                    const hours = ddmmyyyyMatch[4] ? parseInt(ddmmyyyyMatch[4]) : 0;
                    const minutes = ddmmyyyyMatch[5] ? parseInt(ddmmyyyyMatch[5]) : 0;
                    const seconds = ddmmyyyyMatch[6] ? parseInt(ddmmyyyyMatch[6]) : 0;
                    return new Date(year, month, day, hours, minutes, seconds);
                }
                // Fallback to standard parsing
                return new Date(dateValue);
            }
            return null;
        }

        // Get day of week (0=Sunday, 1=Monday, etc.)
        function getDayOfWeek(dateValue) {
            const date = getDateObj(dateValue);
            return date ? date.getDay() : null;
        }

        // Get hour of day
        function getHour(dateValue) {
            const date = getDateObj(dateValue);
            return date ? date.getHours() : null;
        }

        // Get time slot (30-min intervals)
        function getTimeSlot(dateValue) {
            const date = getDateObj(dateValue);
            if (!date) return null;
            const hours = date.getHours();
            const minutes = date.getMinutes();
            return hours * 2 + (minutes >= 30 ? 1 : 0);
        }

        // Format time slot to display string
        function formatTimeSlot(slot) {
            const hours = Math.floor(slot / 2);
            const minutes = (slot % 2) * 30;
            const h = hours.toString().padStart(2, '0');
            const m = minutes.toString().padStart(2, '0');
            return `${h}:${m}`;
        }

        // Main processing function
        function processAndDisplay() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('dashboard').style.display = 'block';

            // Filter data based on global location and view
            let filteredData = getGlobalFilteredData();

            // Update week info
            updateWeekInfo(filteredData);

            // Calculate and display metrics
            const incomingCalls = filteredData.filter(row => row.Direction === 'In');
            updateSummaryMetrics(incomingCalls);

            // Update abandonment analysis
            updateAbandonmentAnalysis(incomingCalls);

            // Update missed call follow-up analysis
            updateMissedCallFollowup(filteredData);

            // Update hourly chart
            updateHourlyChart(filteredData);

            // Update daily table
            updateDailyTable();

            // Update heatmaps
            updateHeatmaps(filteredData);

            // Update staff table
            updateStaffTable(filteredData);
        }

        function updateWeekInfo(data) {
            if (data.length === 0) {
                document.getElementById('weekInfo').textContent = 'No data';
                return;
            }

            let dates = data.map(row => getDateObj(row.CallDateTime)).filter(d => d && !isNaN(d));

            if (dates.length === 0) {
                document.getElementById('weekInfo').textContent = 'No valid dates';
                return;
            }

            const minDate = new Date(Math.min(...dates));
            const maxDate = new Date(Math.max(...dates));

            const formatDate = (d) => d.toLocaleDateString('en-AU', { day: 'numeric', month: 'short' });
            document.getElementById('weekInfo').textContent =
                `${formatDate(minDate)} - ${formatDate(maxDate)} (${data.length} calls)`;
        }

        function updateSummaryMetrics(calls) {
            // Filter out calls with pickup time under threshold (these are excluded from stats)
            const validCalls = calls.filter(c => !(c.TimeToAnswer > 0 && c.TimeToAnswer < MIN_PICKUP_TIME));

            const total = validCalls.length;
            const answered = validCalls.filter(c => c.TimeToAnswer >= MIN_PICKUP_TIME).length;
            const missed = total - answered;
            const missedPct = total > 0 ? ((missed / total) * 100).toFixed(1) : 0;

            const answeredCalls = validCalls.filter(c => c.TimeToAnswer >= MIN_PICKUP_TIME);
            const avgWait = answeredCalls.length > 0
                ? answeredCalls.reduce((sum, c) => sum + (c.TimeToAnswer || 0), 0) / answeredCalls.length
                : 0;
            const maxWait = answeredCalls.length > 0
                ? Math.max(...answeredCalls.map(c => c.TimeToAnswer || 0))
                : 0;

            const callLengths = answeredCalls
                .map(c => (c.CallDuration || 0) - (c.TimeToAnswer || 0))
                .filter(l => l > 0);
            const avgCallLength = callLengths.length > 0
                ? callLengths.reduce((a, b) => a + b, 0) / callLengths.length
                : 0;

            // Service Level: % of answered calls within target time
            const withinTarget = answeredCalls.filter(c => c.TimeToAnswer <= serviceLevelTarget).length;
            const serviceLevel = total > 0 ? ((withinTarget / total) * 100).toFixed(1) : 0;

            // Calculate FCR and Callback Rate
            const { fcrRate, callbackRate } = calculateCallbackMetrics(calls);

            document.getElementById('totalCalls').textContent = total;
            document.getElementById('answeredCalls').textContent = answered;
            document.getElementById('missedCalls').textContent = missed;
            document.getElementById('missedPercent').textContent = missedPct + '%';
            document.getElementById('serviceLevel').textContent = serviceLevel + '%';
            document.getElementById('fcrRate').textContent = fcrRate + '%';
            document.getElementById('callbackRate').textContent = callbackRate + '%';
            document.getElementById('avgWait').textContent = formatTime(avgWait);
            document.getElementById('maxWait').textContent = formatTime(maxWait);
            document.getElementById('avgCallLength').textContent = formatTime(avgCallLength);

            // Out of hours calls (uses rawData, not filtered)
            const outOfHours = countOutOfHoursCalls();
            document.getElementById('outOfHoursCalls').textContent = outOfHours;
        }

        function countOutOfHoursCalls() {
            // Apply global location filter but NOT opening hours filter
            let data = rawData;

            // Apply global location filter
            data = filterByLocation(data, currentGlobalLocation);

            // Apply vasectomy filter if needed
            if (currentView === 'vasectomy') {
                data = data.filter(row => row.CallAlertName === 'Canberra Vasectomy');
            }

            // Count incoming calls OUTSIDE opening hours
            return data.filter(row =>
                row.Direction === 'In' &&
                !isWithinOpeningHours(row.CallDateTime)
            ).length;
        }

        function calculateCallbackMetrics(calls) {
            // Get all incoming calls with valid OriginNumber (answered with TimeToAnswer >= MIN_PICKUP_TIME)
            const validCalls = calls.filter(c =>
                c.OriginNumber &&
                c.OriginNumber !== '0' &&
                c.OriginNumber !== 0
            );

            if (validCalls.length === 0) {
                return { fcrRate: 0, callbackRate: 0 };
            }

            // Group ALL calls by OriginNumber with timestamps
            const callsByNumber = {};
            validCalls.forEach(call => {
                const num = String(call.OriginNumber);
                if (!callsByNumber[num]) {
                    callsByNumber[num] = [];
                }
                const date = getDateObj(call.CallDateTime);
                if (date) {
                    callsByNumber[num].push({
                        call,
                        date,
                        isAnswered: call.TimeToAnswer >= MIN_PICKUP_TIME
                    });
                }
            });

            // Count unique callers who called back within 24 hours
            let uniqueCallersWithCallback = 0;
            let totalUniqueCallers = Object.keys(callsByNumber).length;

            Object.values(callsByNumber).forEach(callList => {
                if (callList.length <= 1) return; // Only one call, no callback

                // Sort by date
                callList.sort((a, b) => a.date - b.date);

                // Check if any two consecutive calls are within the callback window
                let hasCallback = false;
                for (let i = 0; i < callList.length - 1; i++) {
                    const timeDiff = callList[i + 1].date - callList[i].date;
                    const hoursDiff = timeDiff / (1000 * 60 * 60);
                    if (hoursDiff <= callbackWindowHours) {
                        hasCallback = true;
                        break;
                    }
                }

                if (hasCallback) {
                    uniqueCallersWithCallback++;
                }
            });

            const callbackRate = totalUniqueCallers > 0
                ? ((uniqueCallersWithCallback / totalUniqueCallers) * 100).toFixed(1)
                : 0;

            // FCR = unique callers without callback = 100% - callback rate
            const fcrRate = totalUniqueCallers > 0
                ? (100 - parseFloat(callbackRate)).toFixed(1)
                : 0;

            return { fcrRate, callbackRate };
        }

        function updateAbandonmentAnalysis(calls) {
            // Missed calls where TimeToAnswer is 0 or null
            // For missed calls, CallDuration represents how long they waited before hanging up
            const missedCalls = calls.filter(c => !c.TimeToAnswer || c.TimeToAnswer === 0);

            const totalAbandoned = missedCalls.length;
            document.getElementById('totalAbandoned').textContent = totalAbandoned;

            if (totalAbandoned === 0) {
                document.getElementById('avgAbandonWait').textContent = '-';
                document.getElementById('abandonmentGrid').innerHTML =
                    '<p style="color: #95a5a6; font-size: 12px;">No abandoned calls in this period</p>';
                return;
            }

            // Calculate average wait time before abandonment
            const waitTimes = missedCalls.map(c => c.CallDuration || 0);
            const avgWait = waitTimes.reduce((a, b) => a + b, 0) / waitTimes.length;
            document.getElementById('avgAbandonWait').textContent = formatTime(avgWait);

            // Distribution buckets
            const buckets = [
                { label: '<30s', min: 0, max: 30, count: 0 },
                { label: '30-60s', min: 30, max: 60, count: 0 },
                { label: '1-2min', min: 60, max: 120, count: 0 },
                { label: '2-5min', min: 120, max: 300, count: 0 },
                { label: '>5min', min: 300, max: Infinity, count: 0 }
            ];

            missedCalls.forEach(call => {
                const waitTime = call.CallDuration || 0;
                for (const bucket of buckets) {
                    if (waitTime >= bucket.min && waitTime < bucket.max) {
                        bucket.count++;
                        break;
                    }
                }
            });

            let html = '';
            buckets.forEach(bucket => {
                const pct = totalAbandoned > 0 ? ((bucket.count / totalAbandoned) * 100).toFixed(0) : 0;
                html += `
                    <div class="abandonment-bucket">
                        <div class="count">${bucket.count}</div>
                        <div class="range">${bucket.label}</div>
                        <div class="pct">${pct}%</div>
                    </div>
                `;
            });

            document.getElementById('abandonmentGrid').innerHTML = html;
        }

        function toggleFollowupDetails() {
            const btn = document.getElementById('followupExpandBtn');
            const details = document.getElementById('followupDetails');
            btn.classList.toggle('expanded');
            details.classList.toggle('visible');
            btn.innerHTML = btn.classList.contains('expanded')
                ? '<span class="arrow">&#9660;</span> Hide Details'
                : '<span class="arrow">&#9660;</span> Show Details';
        }

        function updateMissedCallFollowup(calls) {
            // Get all incoming calls with valid OriginNumber
            const validCalls = calls.filter(c =>
                c.Direction === 'In' &&
                c.OriginNumber &&
                c.OriginNumber !== '0' &&
                c.OriginNumber !== 0
            );

            if (validCalls.length === 0) {
                document.getElementById('lostOpportunities').textContent = '0';
                document.getElementById('persistentCallers').textContent = '0';
                document.getElementById('lostPeakHour').textContent = '';
                document.getElementById('avgAttempts').textContent = '';
                document.getElementById('attemptsGrid').innerHTML = '<p style="color: #95a5a6; font-size: 12px;">No data</p>';
                document.getElementById('lostPeakHours').innerHTML = '<p style="color: #95a5a6; font-size: 12px;">No data</p>';
                document.getElementById('avgWaitBeforeHangup').textContent = '-';
                return;
            }

            // Group calls by OriginNumber
            const callsByNumber = {};
            validCalls.forEach(call => {
                const num = String(call.OriginNumber);
                if (!callsByNumber[num]) {
                    callsByNumber[num] = [];
                }
                const date = getDateObj(call.CallDateTime);
                if (date) {
                    callsByNumber[num].push({
                        call,
                        date,
                        hour: date.getHours(),
                        isMissed: !call.TimeToAnswer || call.TimeToAnswer === 0,
                        isAnswered: call.TimeToAnswer >= MIN_PICKUP_TIME,
                        waitTime: call.CallDuration || 0
                    });
                }
            });

            // Analyze each unique caller
            let lostCount = 0;
            let persistentCount = 0;
            const lostByHour = {};
            const attemptCounts = { 1: 0, 2: 0, '3+': 0 };
            let totalMissedWaitTime = 0;
            let missedWaitCount = 0;
            const persistentAttempts = [];

            Object.values(callsByNumber).forEach(callList => {
                // Sort by date
                callList.sort((a, b) => a.date - b.date);

                // Find first missed call
                const firstMissedIdx = callList.findIndex(c => c.isMissed);
                if (firstMissedIdx === -1) return; // No missed calls for this number

                const firstMissed = callList[firstMissedIdx];

                // Get all calls within the callback window of the first missed call
                const within24h = callList.filter(c => {
                    const hoursDiff = (c.date - firstMissed.date) / (1000 * 60 * 60);
                    return hoursDiff >= 0 && hoursDiff <= callbackWindowHours;
                });

                // Track wait times for missed calls
                within24h.filter(c => c.isMissed).forEach(c => {
                    totalMissedWaitTime += c.waitTime;
                    missedWaitCount++;
                });

                // Check if they ever got answered within 24h
                const gotAnswered = within24h.some(c => c.isAnswered);

                if (within24h.length === 1 && !gotAnswered) {
                    // Only one missed call, never called back = lost opportunity
                    lostCount++;
                    const hour = firstMissed.hour;
                    lostByHour[hour] = (lostByHour[hour] || 0) + 1;
                } else if (!gotAnswered && within24h.length > 1) {
                    // Called back but never got answered = still lost, but persistent
                    lostCount++;
                    const hour = firstMissed.hour;
                    lostByHour[hour] = (lostByHour[hour] || 0) + 1;
                } else if (gotAnswered) {
                    // Eventually got answered = persistent caller
                    persistentCount++;

                    // Count attempts (missed calls before being answered)
                    const answeredIdx = within24h.findIndex(c => c.isAnswered);
                    const attempts = within24h.slice(0, answeredIdx + 1).filter(c => c.isMissed || c.isAnswered).length;

                    persistentAttempts.push(attempts);

                    if (attempts === 1) attemptCounts[1]++;
                    else if (attempts === 2) attemptCounts[2]++;
                    else attemptCounts['3+']++;
                }
            });

            // Update summary cards
            document.getElementById('lostOpportunities').textContent = lostCount;
            document.getElementById('persistentCallers').textContent = persistentCount;

            // Find peak hour for lost opportunities
            const peakHour = Object.entries(lostByHour).sort((a, b) => b[1] - a[1])[0];
            if (peakHour) {
                const hour = parseInt(peakHour[0]);
                const hourStr = hour > 12 ? `${hour - 12}-${hour - 11}pm` : (hour === 12 ? '12-1pm' : `${hour}-${hour + 1}am`);
                document.getElementById('lostPeakHour').textContent = `Peak: ${hourStr} (${peakHour[1]})`;
            } else {
                document.getElementById('lostPeakHour').textContent = '';
            }

            // Average attempts for persistent callers
            if (persistentAttempts.length > 0) {
                const avgAttempts = (persistentAttempts.reduce((a, b) => a + b, 0) / persistentAttempts.length).toFixed(1);
                document.getElementById('avgAttempts').textContent = `Avg ${avgAttempts} attempts`;
            } else {
                document.getElementById('avgAttempts').textContent = '';
            }

            // Update details section - attempts distribution
            let attemptsHtml = '';
            Object.entries(attemptCounts).forEach(([attempts, count]) => {
                attemptsHtml += `
                    <div class="detail-item">
                        <div class="count">${count}</div>
                        <div class="label">${attempts} attempt${attempts === '1' ? '' : 's'}</div>
                    </div>
                `;
            });
            document.getElementById('attemptsGrid').innerHTML = attemptsHtml || '<p style="color: #95a5a6; font-size: 12px;">No persistent callers</p>';

            // Update details section - peak hours
            const sortedHours = Object.entries(lostByHour)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);

            let peakHoursHtml = '';
            sortedHours.forEach(([hour, count]) => {
                const h = parseInt(hour);
                const hourStr = h > 12 ? `${h - 12}-${h - 11}pm` : (h === 12 ? '12-1pm' : `${h}-${h + 1}am`);
                peakHoursHtml += `<span class="peak-hour-tag">${hourStr}: ${count} lost</span>`;
            });
            document.getElementById('lostPeakHours').innerHTML = peakHoursHtml || '<p style="color: #95a5a6; font-size: 12px;">No lost opportunities</p>';

            // Average wait before hanging up
            const avgWait = missedWaitCount > 0 ? totalMissedWaitTime / missedWaitCount : 0;
            document.getElementById('avgWaitBeforeHangup').textContent = formatTime(avgWait);
        }

        function updateHourlyChart(data) {
            const inCalls = data.filter(row => row.Direction === 'In');
            const outCalls = data.filter(row => row.Direction === 'Out');

            // Hours from 7 to 18 (7 AM to 6 PM)
            const hours = [];
            for (let h = 7; h <= 18; h++) {
                hours.push(h);
            }

            // Count calls per hour
            const inCountsPerHour = hours.map(h =>
                inCalls.filter(c => getHour(c.CallDateTime) === h).length
            );
            const outCountsPerHour = hours.map(h =>
                outCalls.filter(c => getHour(c.CallDateTime) === h).length
            );

            const labels = hours.map(h => {
                const suffix = h >= 12 ? 'PM' : 'AM';
                const hour12 = h > 12 ? h - 12 : (h === 0 ? 12 : h);
                return `${hour12}${suffix}`;
            });

            // Destroy existing chart if any
            if (hourlyChart) {
                hourlyChart.destroy();
            }

            const ctx = document.getElementById('hourlyChart').getContext('2d');
            hourlyChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Calls In',
                            data: inCountsPerHour,
                            borderColor: '#27ae60',
                            backgroundColor: 'rgba(39, 174, 96, 0.1)',
                            fill: true,
                            tension: 0.3,
                            pointRadius: 4,
                            pointHoverRadius: 6
                        },
                        {
                            label: 'Calls Out',
                            data: outCountsPerHour,
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            fill: true,
                            tension: 0.3,
                            pointRadius: 4,
                            pointHoverRadius: 6
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Calls'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Hour of Day'
                            }
                        }
                    }
                }
            });
        }

        function updateDailyTable() {
            let filteredData = getGlobalFilteredData();

            // Further filter by direction
            if (currentDailyDirection === 'in') {
                filteredData = filteredData.filter(row => row.Direction === 'In');
            } else if (currentDailyDirection === 'out') {
                filteredData = filteredData.filter(row => row.Direction === 'Out');
            }

            // Group by day of week
            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const dayData = {};
            dayNames.forEach((name, idx) => {
                dayData[idx] = [];
            });

            filteredData.forEach(row => {
                const day = getDayOfWeek(row.CallDateTime);
                if (day !== null && dayData[day]) {
                    dayData[day].push(row);
                }
            });

            // Calculate metrics for each day
            function calcMetrics(calls) {
                // Filter out calls with pickup time under threshold
                const validCalls = calls.filter(c => !(c.TimeToAnswer > 0 && c.TimeToAnswer < MIN_PICKUP_TIME));

                const total = validCalls.length;
                const answered = validCalls.filter(c => c.TimeToAnswer >= MIN_PICKUP_TIME).length;
                const missed = total - answered;
                const missedPct = total > 0 ? ((missed / total) * 100).toFixed(1) : '-';

                const answeredCalls = validCalls.filter(c => c.TimeToAnswer >= MIN_PICKUP_TIME);
                const avgWait = answeredCalls.length > 0
                    ? answeredCalls.reduce((sum, c) => sum + (c.TimeToAnswer || 0), 0) / answeredCalls.length
                    : null;
                const maxWait = answeredCalls.length > 0
                    ? Math.max(...answeredCalls.map(c => c.TimeToAnswer || 0))
                    : null;

                const callLengths = answeredCalls
                    .map(c => (c.CallDuration || 0) - (c.TimeToAnswer || 0))
                    .filter(l => l > 0);
                const avgCallLength = callLengths.length > 0
                    ? callLengths.reduce((a, b) => a + b, 0) / callLengths.length
                    : null;

                return { total, answered, missed, missedPct, avgWait, maxWait, avgCallLength };
            }

            const metrics = {};
            // Reorder: Mon(1), Tue(2), Wed(3), Thu(4), Fri(5), Sat(6), Sun(0)
            const displayOrder = [1, 2, 3, 4, 5, 6, 0];
            displayOrder.forEach(day => {
                metrics[day] = calcMetrics(dayData[day]);
            });
            const weekMetrics = calcMetrics(filteredData);

            // Build table HTML
            const rows = [
                { label: 'Total Calls', key: 'total', format: v => v },
                { label: 'Answered', key: 'answered', format: v => v },
                { label: 'Missed', key: 'missed', format: v => v },
                { label: 'Missed %', key: 'missedPct', format: v => v === '-' ? v : v + '%' },
                { label: 'Avg Wait', key: 'avgWait', format: formatTimeShort },
                { label: 'Max Wait', key: 'maxWait', format: formatTimeShort },
                { label: 'Avg Call', key: 'avgCallLength', format: formatTimeShort }
            ];

            let html = '';
            rows.forEach(row => {
                html += '<tr>';
                html += `<td style="text-align: left; font-weight: 500;">${row.label}</td>`;
                displayOrder.forEach(day => {
                    const val = metrics[day][row.key];
                    html += `<td>${row.format(val)}</td>`;
                });
                html += `<td style="font-weight: 600; background: #f8f9fa;">${row.format(weekMetrics[row.key])}</td>`;
                html += '</tr>';
            });

            document.getElementById('dailyTableBody').innerHTML = html;
        }

        function updateHeatmaps(data) {
            const inCalls = data.filter(row => row.Direction === 'In');
            const outCalls = data.filter(row => row.Direction === 'Out');

            renderHeatmap('heatmapIn', inCalls);
            renderHeatmap('heatmapOut', outCalls);

            // Render wait time heatmaps (incoming calls only)
            renderWaitTimeHeatmap('heatmapMaxWait', inCalls, 'max');
            renderWaitTimeHeatmap('heatmapAvgWait', inCalls, 'avg');
        }

        function renderHeatmap(elementId, calls) {
            // Time slots from 7:30 AM (slot 15) to 5:30 PM (slot 35)
            const startSlot = 15; // 7:30
            const endSlot = 35;   // 17:30
            const days = [1, 2, 3, 4, 5, 6]; // Mon-Sat
            const dayNames = ['', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

            // Count calls per slot per day
            const counts = {};
            let maxCount = 0;

            for (let slot = startSlot; slot <= endSlot; slot++) {
                counts[slot] = {};
                days.forEach(day => {
                    counts[slot][day] = 0;
                });
            }

            calls.forEach(call => {
                const day = getDayOfWeek(call.CallDateTime);
                const slot = getTimeSlot(call.CallDateTime);
                if (day !== null && slot !== null && days.includes(day) && slot >= startSlot && slot <= endSlot) {
                    counts[slot][day]++;
                    maxCount = Math.max(maxCount, counts[slot][day]);
                }
            });

            // Build heatmap HTML
            let html = '';

            // Header row
            html += '<div class="heatmap-cell heatmap-header"></div>';
            days.forEach(day => {
                html += `<div class="heatmap-cell heatmap-header">${dayNames[day]}</div>`;
            });

            // Data rows
            for (let slot = startSlot; slot <= endSlot; slot++) {
                html += `<div class="heatmap-cell heatmap-time">${formatTimeSlot(slot)}</div>`;
                days.forEach(day => {
                    const count = counts[slot][day];
                    const heatLevel = maxCount > 0 ? Math.min(7, Math.ceil((count / maxCount) * 7)) : 0;
                    html += `<div class="heatmap-cell heat-${heatLevel}" title="${count} calls">${count || ''}</div>`;
                });
            }

            document.getElementById(elementId).innerHTML = html;
        }

        function renderWaitTimeHeatmap(elementId, calls, mode) {
            // Time slots from 7:30 AM (slot 15) to 5:30 PM (slot 35)
            const startSlot = 15; // 7:30
            const endSlot = 35;   // 17:30
            const days = [1, 2, 3, 4, 5, 6]; // Mon-Sat
            const dayNames = ['', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

            // Only include answered calls with TimeToAnswer >= MIN_PICKUP_TIME
            const answeredCalls = calls.filter(c => c.TimeToAnswer >= MIN_PICKUP_TIME);

            // Collect wait times per slot per day
            const waitTimes = {};
            for (let slot = startSlot; slot <= endSlot; slot++) {
                waitTimes[slot] = {};
                days.forEach(day => {
                    waitTimes[slot][day] = [];
                });
            }

            answeredCalls.forEach(call => {
                const day = getDayOfWeek(call.CallDateTime);
                const slot = getTimeSlot(call.CallDateTime);
                if (day !== null && slot !== null && days.includes(day) && slot >= startSlot && slot <= endSlot) {
                    waitTimes[slot][day].push(call.TimeToAnswer);
                }
            });

            // Calculate max or avg for each cell
            const values = {};
            for (let slot = startSlot; slot <= endSlot; slot++) {
                values[slot] = {};
                days.forEach(day => {
                    const times = waitTimes[slot][day];
                    if (times.length === 0) {
                        values[slot][day] = null;
                    } else if (mode === 'max') {
                        values[slot][day] = Math.max(...times);
                    } else {
                        values[slot][day] = times.reduce((a, b) => a + b, 0) / times.length;
                    }
                });
            }

            // Determine heat level based on wait time thresholds (in seconds)
            // 0: no data, 1: <30s, 2: 30-60s, 3: 60-90s, 4: 90-120s, 5: 120-180s, 6: 180-300s, 7: >300s
            function getWaitHeatLevel(seconds) {
                if (seconds === null) return 0;
                if (seconds < 30) return 1;
                if (seconds < 60) return 2;
                if (seconds < 90) return 3;
                if (seconds < 120) return 4;
                if (seconds < 180) return 5;
                if (seconds < 300) return 6;
                return 7;
            }

            // Build heatmap HTML
            let html = '';

            // Header row
            html += '<div class="heatmap-cell heatmap-header"></div>';
            days.forEach(day => {
                html += `<div class="heatmap-cell heatmap-header">${dayNames[day]}</div>`;
            });

            // Data rows
            for (let slot = startSlot; slot <= endSlot; slot++) {
                html += `<div class="heatmap-cell heatmap-time">${formatTimeSlot(slot)}</div>`;
                days.forEach(day => {
                    const val = values[slot][day];
                    const heatLevel = getWaitHeatLevel(val);
                    const displayVal = val !== null ? formatTimeShort(val) : '';
                    const titleText = val !== null ? `${mode === 'max' ? 'Max' : 'Avg'}: ${formatTime(val)}` : 'No calls';
                    html += `<div class="heatmap-cell wait-heat-${heatLevel}" title="${titleText}">${displayVal}</div>`;
                });
            }

            document.getElementById(elementId).innerHTML = html;
        }

        function updateStaffTable(data) {
            // Apply location filter
            const locationFilteredData = filterByLocation(data, currentLocationFilter);

            // Group by staff member
            const staffStats = {};

            locationFilteredData.forEach(row => {
                const name = row.UserName;
                if (!name || name === '0' || name === 0) return;

                if (!staffStats[name]) {
                    staffStats[name] = {
                        name: name,
                        callsIn: 0,
                        callsOut: 0,
                        totalPickupTime: 0,
                        pickupCount: 0,
                        totalCallLengthIn: 0,
                        callLengthCountIn: 0,
                        totalCallLengthOut: 0,
                        callLengthCountOut: 0
                    };
                }

                const stats = staffStats[name];

                if (row.Direction === 'In') {
                    // Skip calls with pickup time under threshold
                    if (row.TimeToAnswer > 0 && row.TimeToAnswer < MIN_PICKUP_TIME) {
                        return; // Exclude from stats entirely
                    }
                    stats.callsIn++;
                    if (row.TimeToAnswer >= MIN_PICKUP_TIME) {
                        stats.totalPickupTime += row.TimeToAnswer;
                        stats.pickupCount++;
                        const callLength = (row.CallDuration || 0) - (row.TimeToAnswer || 0);
                        if (callLength > 0) {
                            stats.totalCallLengthIn += callLength;
                            stats.callLengthCountIn++;
                        }
                    }
                } else if (row.Direction === 'Out') {
                    stats.callsOut++;
                    if (row.CallDuration > 0) {
                        stats.totalCallLengthOut += row.CallDuration;
                        stats.callLengthCountOut++;
                    }
                }
            });

            // Convert to array and sort by total calls
            const staffArray = Object.values(staffStats)
                .map(s => ({
                    ...s,
                    totalCalls: s.callsIn + s.callsOut,
                    avgPickup: s.pickupCount > 0 ? s.totalPickupTime / s.pickupCount : null,
                    avgCallLengthIn: s.callLengthCountIn > 0 ? s.totalCallLengthIn / s.callLengthCountIn : null,
                    avgCallLengthOut: s.callLengthCountOut > 0 ? s.totalCallLengthOut / s.callLengthCountOut : null
                }))
                .sort((a, b) => b.totalCalls - a.totalCalls);

            // Build table HTML
            let html = '';
            staffArray.forEach(staff => {
                html += '<tr>';
                html += `<td style="text-align: left;">${staff.name}</td>`;
                html += `<td>${staff.callsIn}</td>`;
                html += `<td>${staff.callsOut}</td>`;
                html += `<td style="font-weight: 600;">${staff.totalCalls}</td>`;
                html += `<td>${formatTime(staff.avgPickup)}</td>`;
                html += `<td>${formatTime(staff.avgCallLengthIn)}</td>`;
                html += `<td>${formatTime(staff.avgCallLengthOut)}</td>`;
                html += '</tr>';
            });

            document.getElementById('staffTableBody').innerHTML = html;
        }
    </script>
</body>
</html>
